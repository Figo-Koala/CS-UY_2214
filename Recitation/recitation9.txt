1.

For register operations, the average CPI without stalls is 4, while with stalls it increases to 10. Memory instructions with stalls have an average CPI of about 30.
To find the overall average CPI, we multiply each CPI by its corresponding instruction frequency and sum the results:
(0.80×4)+(0.15×10)+(0.05×30)=6.2
Thus, the program’s overall average CPI is 6.2.


2.

a. A data conflict occurs due to a read-after-write (RAW) hazard on register $1. Instruction 1 writes to $1, while Instructions 2 and 3 both read from it. Because these later instructions must wait for Instruction 1 to finish writing the correct value to $1, a data hazard arises on that register.

b. Line 2 experiences a read-after-write conflict, and there is also a write-after-write conflict between lines 1 and 2.

c. A write-after-write hazard occurs between lines 1 and 3 because both instructions write to the same memory address, 0($4).

d. The instruction jal writes to register $7, while line 1 reads from $7, creating a write-after-read hazard between the two instructions.

e. A control hazard occurs because the `jr` instruction in line 2 performs an unconditional jump based on the value in $1. This also introduces a read-after-write hazard, since `jr` may attempt to read from $1 before the correct value has been written to it.

f. There is no conflict in this question.3

g. Line 2 reads from $1 before the value 40 is written to it, and line 4 reads from $1 before 50 is written. This creates a write-after-write  hazard. Additionally, there is a write-after-read hazard involving lines 2 and 3.


3.

a. Since instructions in lines 2 and 3 both depend on the result of instruction 1, the hazard remains. However, a valid reordering that preserves correctness is {1, 3, 2}.

b. Reordering in this case does not make a major difference unless the final value of $1 must be 25. The write-after-write hazard persists regardless of order, though the results may vary. To ensure correctness, it’s safest to keep the original order.

c. Instruction 2 is independent and can be swapped with either instruction 1 or 3. However, instructions 1 and 3 must stay in order to preserve the correct program output. Valid reorderings include {1, 3, 2} and {2, 1, 3}.

d. Because there is a control hazard caused by the `jal` in line 4, the `jal` must remain last. Instructions 1, 2, and 3, which are independent, can be freely reordered. Valid reorderings include {1, 2, 3, 4}, {1, 3, 2, 4}, {2, 1, 3, 4}, (2, 3, 1, 4}, {3, 1, 2, 4}, and {3, 2, 1, 4}.

e. A control hazard exists due to the `jr` instruction, and since `jr` depends on $1 being loaded with the correct value, no valid reordering is possible.

f. There are no data or control hazards, as all instructions are independent. Therefore, any ordering of instructions 1, 2, and 3 is valid, including {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, and {3, 2, 1}.

g. There is a write-after-write hazard on $1 between instructions 1 and 3, and another on memory between instructions 2 and 4. If the intended final results are to store the value 40 at memory address 0 and 50 at memory address 1, it is best not to reorder the instructions, as doing so may alter the final output.

4.

a.
ram[1]: A read-after-write hazard occurs because the `lw` instruction has not yet completed writing its result. There is also a control hazard caused by the `jeq`, since the next instruction could come from either PC + imm + 1 or PC + 1.
ram[3]: A read-after-write hazard exists because the `lw` instruction has not finished writing its value.
ram[4]: A read-after-write hazard occurs because the `addi` instruction from ram[3] may not have completed execution yet.

b.
		lw $1, data($0)       # Load data[$0] -> $1.
		nop                   # Wait lw completion.
		nop                   # Wait lw completion.
		nop                   # Wait lw completion.
		jeq $1, $0, skip      # If $1 == $0, jump to skip.
		addi $3, $0, 0        # Add ($0 + 0) -> $3.
		addi $2, $1, 5        # Add ($1 + 5) -> $2.
		nop                   # Wait addi completion.
		nop                   # Wait addi completion.
		nop                   # Wait addi completion.
		sub $3, $1, $2        # Subtract ($1 - $2) -> $3.
	skip:
		halt                  # Terminate the program.
	data: 
		.fill 10              # Fill data[0] with value 10.

		





